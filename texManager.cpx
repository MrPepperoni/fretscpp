
interface

uses includes, sprites;
/*
 * This avoids loading the same texture multiple times and handles
 * context loss gracefully on Windows
 * */

int texLoad(const char *c);
int texLoad(string s, int flags=0);
void texRelease(int i);
void texBind(int i);
void texUnbind();
void texDraw(int i);
void texReleaseAll();
void texReloadAll();
GLfloat texAspect(int i);

implementation

vector<sprite> tmag;

int texLoad(const char *c)
{
	return texLoad(string(c));
}

int texLoad(string s, int flags)
{
	int i,found=-1;
	if (!(flags&1)) s=datadir+"/"+s;
	for (i=0; i<tmag.size(); i++) 
		if (tmag[i].name==s) 
		{ 
			found=i; 
			INFO(TEXMAN,"Texture %s already in database, entry #%d\n" &s &found);
			break; 
		}
	if (found<0) 
	{
		found=tmag.size();
		tmag.push_back(sprite());
		tmag[found].name=s;
		tmag[found].tex=0;
		tmag[found].refcount=0;
	}
	tmag[found].refcount++;
	if (!tmag[found].tex) 
	{
		INFO(TEXMAN,"Loading %s as #%d\n" &s &found);
		tmag[found].loadInternal(s);
	}
	return found;
}

void texRelease(int i)
{
	if (i<0) return;
	tmag[i].refcount--;
	if (tmag[i].refcount<0)
	{
		tmag[i].refcount=0;
		WARN(TEXMAN,"Texture refcount<0: %s\n" &tmag[i].name);
	}
}

void texBind(int i)
{
	if (i<0) return;
	glBindTexture(GL_TEXTURE_2D,tmag[i].tex);
}

void texUnbind()
{
	glBindTexture(GL_TEXTURE_2D,0);
}

void texDraw(int i)
{
	if (i<0) return;
	GLfloat txhe=tmag[i].txhe;
	GLfloat txwi=tmag[i].txwi;
	glBindTexture(GL_TEXTURE_2D,tmag[i].tex);
	glBegin(GL_TRIANGLE_STRIP);
	glTexCoord2f(0.0 , txhe); glVertex3f(-1, -1, 0);
	glTexCoord2f(txwi, txhe); glVertex3f( 1, -1, 0);
	glTexCoord2f(0.0 , 0   ); glVertex3f(-1,  1, 0);
	glTexCoord2f(txwi, 0   ); glVertex3f( 1,  1, 0);
	glEnd();
	glBindTexture(GL_TEXTURE_2D,0);
}

GLfloat texAspect(int i)
{
	if (i<0) return 1;
	return GLfloat(tmag[i].height)/tmag[i].width;
}

void texReleaseAll()
{
	int i;
	for (i=0; i<tmag.size(); i++)
	{
		if (!tmag[i].tex) continue;
		glDeleteTextures(1,&tmag[i].tex);
		tmag[i].tex=0;
	}
}

void texReloadAll()
{
	int i;
	for (i=0; i<tmag.size(); i++)
	{
		tmag[i].tex=0;
		if (!tmag[i].refcount) 
			continue;
		tmag[i].loadInternal(tmag[i].name);
	}
}
