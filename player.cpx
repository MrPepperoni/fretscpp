/*******************************************************************
(C) 2010 by Radu Stefan
radu124@gmail.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*******************************************************************/  
  
interface

uses midiparser;

class tPlayer
{
public:
	int lefty;
	int score;
	int streak;
	int lastkeys[6];
	int lasthit[6]; // time of last hit per key [5]=any
	int keys;
	int hit;
	int longeststreak;
	int crtnote;
	int nextnote;
	int donenote;
	int farrnote;
	int hittnote;
	int id;
	int crtnotehit;
	int multiplier;
	int instrument;
	int difficulty;
	int hitactive;
	int scorefrac;
	int notegood;
	int notetotal;
	int notexmiss;
	int notehopo;
	int lasttime; // last time we called passtime()
	int timemultiplier;
	int whammy;
	int whammyon;
	// how much of the current note they player already
	// got credit for (timestamp)
	int holdaccounted; 
	int enabled;
	int whammyaxislast;
	string name;
	string lastInstr;
	int lastDiffi;
	int scorenomult;
	int scorehits;
	int scorehold;
	int scorewham;
	
	void handlehit();
	void passtime();
	void init(int iid);
	void presskey(int i);
	void releasekey(int i);
	void unhitactive(int ts);
	void holdscore(int ts);
	void addwhammy(int i);
	void whammyaxis(int v);
	int notematch(int i);
	vector<notestatus> *cnotes;
	vector<int> history;
};

const int MAX_PLAYERS=4;

tPlayer player[MAX_PLAYERS];

implementation

uses audio,scnGuitar,scnSetSongOpt;

void tPlayer::whammyaxis(int v)
{
	int addv=abs(whammyaxislast-v);
	if (addv>50000) addv=50000;
	whammyaxislast=v;
	addwhammy(addv);
}

void tPlayer::addwhammy(int i)
{
	if (hitactive) whammy+=i;
}

void tPlayer::presskey(int i)
{
	lastkeys[i]=1;
	if (i<5) unhitactive(guitarScene.timenow);	
	if (i>=5 && i<=6) handlehit(); 
	if (i==7) addwhammy(15000);
}

void tPlayer::releasekey(int i)
{
	lastkeys[i]=0;
	if (i<5) unhitactive(guitarScene.timenow);
}

void tPlayer::holdscore(int ts)
{
// guitarscene line 334
	const int SCOREDIV=441;
	int multiplier=1+streak/10;
	int scoreplus;
	if (multiplier>4) multiplier=4;
	if (ts<holdaccounted) return;
	scoreplus=multiplier*(ts-holdaccounted);
	if (whammyon) scoreplus*=2;
	scorefrac+=scoreplus; //hitactive*
	holdaccounted=ts;
	score+=scorefrac/SCOREDIV;
	scorehold+=scorefrac/SCOREDIV;
	if (whammyon) scorewham+=scorefrac/SCOREDIV/2;
	scorenomult+=(scorefrac/SCOREDIV+multiplier-1)/multiplier; // not really good
	scorefrac%=SCOREDIV;
}

void tPlayer::unhitactive(int ts)
{
	if (hitactive)
		holdscore(ts);
	hitactive=0;
}

void tPlayer::init(int iid)
{
	int i;
	id=iid;
	whammy=0;
	longeststreak=0;
	scorefrac=0;
	scorenomult=0;
	scorehits=0;
	scorehold=0;
	scorewham=0;
	crtnote=0;
	hittnote=-1;
	nextnote=0;
	cnotes=&crtSong.trk_notes[instrument];
	notetotal=0;
	notegood=0;
	notexmiss=0;
	notehopo=0;
	streak=0;
	lasttime=0;
	for (i=0; i<cnotes->size(); i++) if (cnotes[0][i].hashit(difficulty)) notetotal++;
	history.resize(cnotes->size());
	for (i=0; i<history.size(); i++) history[i]=0;
	// for visual effects
	timemultiplier=-1000000;
	for (i=0; i<5; i++) lasthit[i]=-1000000;
}

void tPlayer::passtime()
{
	int timenow=guitarScene.timenow;
	int timeincr=timenow-lasttime;
	int j;
	lasttime=timenow;
	if (timeincr>0)
	{
		// whammy fades out
		whammy=(int) (whammy*exp(-timeincr*0.0001)-timeincr*0.01);
		if (whammy<0) whammy=0;
	}
	playing.wh[id]=whammyon=hitactive && (whammy>5000) && (timenow-lasthit[5]>20000);
	while (crtnote<crtSong.trk_notes[instrument].size())
	{
		notestatus &cn=cnotes[0][crtnote];
		if (cn.timestamp>timenow-44*tolerance_late) break;
		if (hitactive && !cn.hasline(difficulty)) unhitactive(cn.timestamp);
		if (cnotes[0][crtnote].hashit(difficulty)) 
		{
			hitactive=0;
			streak=0;
			playing.gp[id]=0;
		}
		crtnote++;
	}
	if (hitactive) holdscore(timenow);
}

int tPlayer::notematch(int i)
{
	int j;
	for (j=0; j<5; j++)
	{
		char c=cnotes[0][i].stat[j+12*difficulty];
		if ((c=='O' || c=='B') ^ (lastkeys[j])) return 0;
		if (lastkeys[j]) c++;
	}
	return 1;
}

void tPlayer::handlehit()
{
	int timenow=guitarScene.timenow;
	int i,found=-1,good=0,j;
	int multiplier=streak/10+1;
	if (multiplier>4) multiplier=4;
	for (i=crtnote; i<crtSong.trk_notes[instrument].size(); i++)
	{
		if (cnotes[0][i].timestamp>timenow+44*tolerance_early) break;
		if (cnotes[0][i].hashit(difficulty)) 
		{
			// try to match anything within the window
			if (notematch(i)) 
			{ 
				found=i; 
				crtnote=i+1; 
				good=1;
				break; 
			}
		}
	}
	if (good) {
		for (i=0; i<5; i++)
			if (lastkeys[i]) lasthit[i]=timenow;
		lasthit[5]=timenow;
		streak++;
		if (streak>longeststreak) longeststreak=streak;
		playing.gp[id]=1;
		hitactive=cnotes[0][crtnote-1].hashit(difficulty);
		notegood++;
		history[crtnote-1]=2;
		score+=50*hitactive*multiplier;
		scorenomult+=50*hitactive;
		scorehits+=50*hitactive*multiplier;
		holdaccounted=cnotes[0][crtnote-1].timestamp+8000; // actually song.period*1.1/4
		if (streak==10 || streak==20 || streak==30) timemultiplier=timenow;
	}
	else {
		effect_start(1+rand()%4,0);
		streak=0;
		playing.gp[id]=0;
		hitactive=0;
		notexmiss++;
	}
}
