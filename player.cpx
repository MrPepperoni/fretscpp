/*******************************************************************
(C) 2010 by Radu Stefan
radu124@gmail.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*******************************************************************/  
  
interface

class tPlayer
{
public:
	int lefty;
	int score;
	int streak;
	int lastkeys[6];
	int lasthit[5];
	int keys;
	int hit;
	int crtnote;
	int nextnote;
	int donenote;
	int farrnote;
	int hittnote;
	int id;
	int crtnotehit;
	int multiplier;
	int instrument;
	int difficulty;
	int hitactive;
	int scorefrac;
	int notegood;
	int notetotal;
	int notexmiss;
	
	int timemultiplier;
	
	// how much of the current note they player already
	// got credit for (timestamp)
	int holdaccounted; 
	
	string name;
	
	void handlehit();
	void passtime();
	void init(int iid);
	void presskey(int i);
	void releasekey(int i);
	void unhitactive(int ts);
	void holdscore(int ts);
	int notematch(int i);
	vector<notestatus> *cnotes;
	vector<int> history;
};

tPlayer player[2];

implementation

uses audio;

void tPlayer::presskey(int i)
{
	lastkeys[i]=1;
	if (i<5) unhitactive(playing.playpos);	
	if (i>=5) handlehit(); 
}

void tPlayer::releasekey(int i)
{
	lastkeys[i]=0;
	if (i<5) unhitactive(playing.playpos);
}

void tPlayer::holdscore(int ts)
{
	const int SCOREDIV=180;
	int multiplier=1+streak/10;
	if (multiplier>4) multiplier=4;
	if (ts<holdaccounted) return;
	scorefrac+=multiplier*(ts-holdaccounted); //hitactive*
	holdaccounted=ts;
	score+=scorefrac/SCOREDIV;
	scorefrac%=SCOREDIV;
}

void tPlayer::unhitactive(int ts)
{
	holdscore(ts);
	hitactive=0;
}

void tPlayer::init(int iid)
{
	int i;
	id=iid;
	scorefrac=0;
	crtnote=0;
	hittnote=-1;
	nextnote=0;
	cnotes=&crtSong.trk_notes[instrument];
	notetotal=0;
	notegood=0;
	notexmiss=0;
	for (i=0; i<cnotes->size(); i++) if (cnotes[0][i].hashit(difficulty)) notetotal++;
	history.resize(cnotes->size());
	for (i=0; i<history.size(); i++) history[i]=0;
	// for visual effects
	timemultiplier=-1000000;
	for (i=0; i<5; i++) lasthit[i]=-1000000;
}

void tPlayer::passtime()
{
	int timenow=playing.playpos;
	int j;
	while (crtnote<crtSong.trk_notes[instrument].size())
	{
		notestatus &cn=cnotes[0][crtnote];
		if (cn.timestamp>timenow-4000) break;
		if (hitactive && !cn.hasline(difficulty)) unhitactive(cn.timestamp);
		if (cnotes[0][crtnote].hashit(difficulty)) 
		{
			hitactive=0;
			streak=0;
			playing.gp0=0;
		}
		crtnote++;
	}
	if (hitactive) holdscore(timenow);
}

int tPlayer::notematch(int i)
{
	int j;
	for (j=0; j<5; j++)
	{
		char c=cnotes[0][i].stat[j+12*difficulty];
		if ((c=='O' || c=='B') ^ (lastkeys[j])) return 0;
		if (lastkeys[j]) c++;
	}
	return 1;
}

void tPlayer::handlehit()
{
	int timenow=playing.playpos;
	int i,found=-1,good=0,j;
	int multiplier=streak/10+1;
	if (multiplier>4) multiplier=4;
	for (i=crtnote; i<crtSong.trk_notes[instrument].size(); i++)
	{
		if (cnotes[0][i].timestamp>timenow+4000) break;
		if (cnotes[0][i].hashit(difficulty)) 
		{
			// try to match anything within the window
			if (notematch(i)) 
			{ 
				found=i; 
				crtnote=i+1; 
				good=1;
				break; 
			}
		}
	}
	if (good) {
		for (i=0; i<5; i++)
			if (lastkeys[i]) lasthit[i]=timenow;
		
		streak++;
		playing.gp0=1;
		hitactive=cnotes[0][crtnote-1].hashit(difficulty);
		notegood++;
		history[crtnote-1]=2;
		score+=50*hitactive*multiplier;
		holdaccounted=cnotes[0][crtnote-1].timestamp+5500;
		if (streak==10 || streak==20 || streak==30) timemultiplier=timenow;
	}
	else {
		effect_start(1+rand()%4,0);
		streak=0;
		playing.gp0=0;
		hitactive=0;
		notexmiss++;
	}
}
