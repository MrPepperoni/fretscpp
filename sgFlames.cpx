interface

implementation

uses scnGuitar;

void tSceneGuitar::renderFlame(int col, GLfloat sz)
{
}

void tSceneGuitar::renderFlames()
{
	int i;
	tPlayer &pp=player[cplayer];
	for (i=0; i<4; i++) 
	{
		if ((pp.hitactive && pp.lastkeys[i])
			|| (pp.lasthit[i]+20000>timenow))
		{
			rfFlame(i,1);
		}
	}
//	rfFlame(0,1);
//	origGlow(4);
}

void tSceneGuitar::rfFlame(int n, GLfloat sz)
{
	GLfloat x,y,v,f,ff,ms,flameSize,flameColor[4];
	GLfloat fcMod[3]={1.197,1.971,10.592};
	GLfloat fcMof[3]={1.197,1.784,12.222};
	v=0; // don't know
    f = 0.5; // = self.fretWeight[n];
    GLfloat c[3]={1,1,1}; //= self.fretColors[n];
    if (0) //f and (controls.getState(self.actions[0]) or controls.getState(self.actions[1])):
		f += 0.25;      
	y = v + f / 6;
	x = n-2;
	f = 0.1; //self.fretActivity[n]

	if (f==0) return;

	ms = sin(scn.timesc*1000) * .25 + 1;
	ff = f+1.2;
	
	glBlendFunc(GL_ONE, GL_ONE);

	flameSize = 0.2;//self.flameSizes[self.scoreMultiplier - 1][n]        
	flameColor[0] = 0.6;
	flameColor[1] = 0.5;
	flameColor[2] = 0.05;//self.flameColors[self.scoreMultiplier - 1][n]
	
	//if flameColor[0] == -2:
	//	flameColor = self.fretColors[n]

	glColor3f(flameColor[0] * fcMod[0], flameColor[1] * fcMod[1], flameColor[2] * fcMod[2]);          
	glPushMatrix();
	glTranslatef(x, -boardline, 0);
	glRotatef(60, 1, 0, 0);
	glTranslatef(0, y, 0);
	glScalef((0.5 + .6 * ms * ff) * ff *flameSize, (1 + .6 * ms * ff)*ff*flameSize,1);
	glTranslatef(0, 0.5, 0);
	spc.hitg1.draw3d();
	glPopMatrix();

	ff += .3;

	//flameSize = self.flameSizes[self.scoreMultiplier - 1][n]
	//flameColor = self.flameColors[self.scoreMultiplier - 1][n]

	glColor3f(flameColor[0] * fcMof[0], flameColor[1] * fcMof[1], flameColor[2] * fcMof[2]);
	glPushMatrix();
	glTranslatef(x, -boardline, 0);
	glRotatef(60, 1, 0, 0);
	glTranslatef(0, y, 0);
	glScalef((.40 + .6 * ms * ff)*flameSize*ff, (1 + .6 * ms * ff) *flameSize*ff,1);
	glTranslatef(0, 0.5, 0);
	spc.hitg2.draw3d();
	glPopMatrix();
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}

void tSceneGuitar::origGlow(int n)
{
	GLfloat s=0.0;
	GLfloat size[2];
	GLfloat x,y,t,sf,isf=0;
	GLfloat f=1;
	x=n-2;
	y=-boardline;
	
	glBlendFunc(GL_SRC_ALPHA, GL_ONE);
	glPushMatrix();
	glTranslatef(x, y, 0);
	glRotatef(f + scn.time * 100, 0, 0, 1);
	size[0] = .22 * (f + 1.5);
	size[1] = .22 * (f + 1.5);

	//if self.playedNotes:
		//t = cos(math.pi + (self.time - self.playedNotes[0][0]) * 0.01)
	//else:
		t = cos(scn.time * 10);

	sf=f*size[0];
	if (sf!=0) isf=1/sf;
	glScalef(sf,sf,0);
		
	while (s < .5)
	{
		ms = (1 - s) * f * t * .25 + .75;
		glColor3f(keycolors[n][0] * ms, keycolors[n][1] * ms, keycolors[n][2] * ms);
		spc.glow.draw3d();
		glTranslatef(0, ms * .1, 0);
		glScalef(.8, 1, .8);
		glRotatef(ms * 20, 0, 0, 1);
		s += 0.2;
	}
	glPopMatrix();
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}
