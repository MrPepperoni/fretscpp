interface

uses includes,globals,scene,sprites,stagefx;

enum SLBLENDTYPE { SLB_DEFAULT=0, SLB_ONE };

#define SLINI_LIST \
SLPD(int, xres, 256) \
SLPD(int, yres, 256) \
SLPD(int, players, 255) \
SLPD(string, texture, "") \
SLPD(mcolor, color, C_WHITE) \
SLPD(GLfloat, xscale, 1) \
SLPD(GLfloat, scale, 1) \
SLPD(GLfloat, yscale, 1) \
SLPD(GLfloat, xpos, 0) \
SLPD(GLfloat, ypos, 0) \
SLPD(GLfloat, xcenter, 0) \
SLPD(GLfloat, ycenter, 0) \
SLPD(GLfloat, angle, 0) \
SLPD(SLBLENDTYPE, src_blending, SLB_DEFAULT) \
SLPD(SLBLENDTYPE, dst_blending, SLB_DEFAULT) \
SLPD(int, foreground, 0)

#define SLPD_DECLARE(a,b,c) a lv_##b;
#define SLPD_INIT(a,b,c) lv_##b = c;
#define SLPD_READ(a,b,c) if (tsimatch(line,"" #b)) { confread_##a(line,lv_##b); return; }
MULTIRDR(SLBLENDTYPE,"default,one")

class Stage;

class StageLayer
{
public:
	string name;
	Stage *parent;
	int texid;
	mcolor color;
	int isBackground;
	vector<StageLayerFx*> fx;
	StageLayer()
	{
#define SLPD SLPD_INIT
	SLINI_LIST
#undef SLPD
	}
	void read(char *line)
	{
#define SLPD SLPD_READ
	SLINI_LIST
#undef SLPD
	}
	void render();
#define SLPD SLPD_DECLARE
	SLINI_LIST
#undef SLPD
};

class Stage
{
public:
	vector<StageLayer*> layer;
	void readDir(string d);
	void cleanup();
	void render();
	void renderForeground();
	StageLayer *findLayer(string name);
	StageLayerFx *findFX(StageLayer *base, string name);
	~Stage() { cleanup();}
};

implementation

uses configuration,texManager;

void StageLayer::render()
{
	int i;
	if (isBackground)
	{
		glClearColor( lv_color.Red, lv_color.Green, lv_color.Blue, 0 );
		glClear( GL_COLOR_BUFFER_BIT );	
		return;
	}
	glPushMatrix();
	if (lv_src_blending) glBlendFunc(GL_SRC_ALPHA, GL_ONE);	
	color=lv_color;
	glTranslatef(40*lv_xpos,30*lv_ypos,0);
	for (i=0; i<fx.size(); i++) fx[i]->apply(color);
	glScalef(10*lv_xscale,-10*lv_yscale,0);
	if (lv_angle!=0) glRotatef(-lv_angle,0,0,1);
	color.set();
	texDraw(texid);
	if (lv_src_blending) glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glPopMatrix();
}

StageLayer *Stage::findLayer(string name)
{
	int v=-1,i;
	for (i=0; i<layer.size(); i++)
		if (layer[i]->name==name) v=i;
	if (v<0)
	{
		StageLayer *a=new StageLayer();
		a->name=name;
		a->isBackground=(a->name=="background");
		layer.push_back(a);
		DBG(STAGE,"Stage: new layer %s\n", name);
		a->parent=this;
		return a;
	}
	return layer[v];
}

StageLayerFx *Stage::findFX(StageLayer *base, string name)
{
	int v=-1,i;
	for (i=0; i<base->fx.size(); i++)
		if (base->fx[i]->name==name) v=i;
	if (v<0)
	{
		StageLayerFx *a=new StageLayerFx();
		a->name=name;
		base->fx.push_back(a);
		DBG(STAGE,"Stage: new fx %s (layer %s)\n", name, base->name);
		a->parent=base;
		return a;
	}
	return base->fx[v];
}
	

void Stage::readDir(string d)
{
	char line[1024];
	int mode=0;
	int i;
	StageLayer *crtl=NULL;
	StageLayerFx *crtf=NULL;
	FILE *fc=fopen((d+"/stage.ini").c_str(),"r");
	if (!fc) return;
	
	while (!feof(fc))
	{
		fgets(line,999,fc);
		char *p, *sav, *fxs;
		// eliminate CR,LF at the end of line
		p=line+strlen(line)-1;
		while (p>=line) 
		{
			if (*p!=10 && *p!=13) break;
			*p=0;
		}
		p=line;
		while (*p==' ' || *p=='\t') p++;
		if (*p=='[')
		{
			sav=++p;
			while (*p!=']' && *p) p++;
			*p=0;
			fxs=strchr(sav,':');
			if (fxs) {
				*fxs=0;
				fxs++;
				mode=2;
				crtl=findLayer(sav);
				crtf=findFX(crtl,fxs);
			} else {
				mode=1;
				crtl=findLayer(sav);
			}
			continue;
		}
		if (*p==';')
			continue;
		if (mode==1) crtl->read(p);
		if (mode==2) crtf->read(p);
	}
	for (i=0; i<layer.size(); i++) layer[i]->texid=-1;
	for (i=0; i<layer.size(); i++) if (layer[i]->lv_texture!="")
	{
		string txname=layer[i]->lv_texture;
		int pos=txname.rfind(".svg");
		if (pos!=string::npos)
			txname.replace(pos,4,".png");
		else if (txname[0]=='/') layer[i]->texid=texLoad(txname.substr(1,999));
		else layer[i]->texid=texLoad(d+"/"+txname,1);
		
		layer[i]->lv_yscale=layer[i]->lv_yscale*texAspect(layer[i]->texid);
		layer[i]->lv_yscale*=layer[i]->lv_scale;
		layer[i]->lv_xscale*=layer[i]->lv_scale;
	}
	fclose(fc);
}

void Stage::cleanup()
{
	int i;
	for (i=0; i<layer.size(); i++)
	{
		if (layer[i]->texid>=0) texRelease(layer[i]->texid);
		delete layer[i];
	}
	layer.resize(0);
}

void Stage::render()
{
	int i;
	for (i=0; i<layer.size(); i++) 
	{
		if (layer[i]->lv_foreground) continue;
		if (!(layer[i]->lv_players & (1<<(numplayers-1)))) continue;
		layer[i]->render();
	}
}

void Stage::renderForeground()
{
	int i;
	for (i=0; i<layer.size(); i++) 
	{	
		if (!layer[i]->lv_foreground) continue;
		if (!(layer[i]->lv_players & (1<<(numplayers-1)))) continue;
		layer[i]->render();
	}
}
