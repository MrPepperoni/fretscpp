/*******************************************************************
(C) 2010 by Radu Stefan
radu124@gmail.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*******************************************************************/  

interface

uses includes, verbosity, scene;

class tScnSongs:public sceneBase
{
public:
	tScnSongs();
	void init();
	void render();
	void handleevent(SDL_Event &a);
	GLfloat fadespeed() { return 100; }
	GLfloat scale;
	int previewsong;
	int selected;
	int previewlock;
	GLfloat selecttime;
	int viewOffset;
	void enter();
} scnSongs;

implementation

uses songsdb,sprites,audio;

tScnSongs::tScnSongs()
{
	scenes.add(this,SCN_SONGS); 
	previewsong=-1;
	previewlock=-1;
}

void tScnSongs::enter()
{
	SDL_EnableKeyRepeat(133,33);
}

void tScnSongs::render()
{
	GLfloat x,y;
	paintrotback();
	scale=h*0.05;
	y=scale*2;
	x=scale;
	if (songsdb.size()==0) updatesongdb();
	
	int i;
	
	for (i=viewOffset; i<viewOffset+16 && i<songsdb.size(); i++)
	{
		glLoadIdentity();
		glColor3f(0.0f,0.0f,0.0f);
		GLfloat dy=0;
		string item=songsdb[i].name;
		if (selected==i && scn.fade==0)
			dy=sin(scn.time*8)*scale*0.1;
		//deffont.displayString(item.c_str(),x-scale*0.05,y+scale*0.05+dy,scale);
		
		if (selected==i && scn.fade==0)
			glColor3f(1.0f,0.7f,0.0f);
		else if (previewlock==i) 
		{
			glColor3f(0.9f,0.1f,0.0f);	
		}
		else {
			glColor3f(0.8f,0.3f,0.0f);	
		}
		if (previewlock==i) 
			item+=" (preview)";
		deffont.displayString(item.c_str(),x           ,y+dy           ,scale);
		//deffont.displayString("====",0           ,i*32           ,32);
		y=y+scale;
	}
	if (previewlock>=0)
	{
		if (previewlock!=previewsong)
		{
			previewsong=previewlock;
			string sp=songsdb[previewlock].dir+"/";
			song_start(sp.c_str());
		}
	}
	else if (previewsong!=selected && scn.time>selecttime+0.5)
	{
		previewsong=selected;
		string sp=songsdb[selected].dir+"/";
		song_start(sp.c_str());
	}
}

void tScnSongs::handleevent(SDL_Event &event)
{
	int oldsel=selected;
	int actkey;
	switch (event.type)
	{
	case SDL_KEYDOWN:
		actkey=event.key.keysym.sym;
		// may need to process this one to intercept other keys
		switch (actkey) 
		{
		case SDLK_ESCAPE:
			scn.nextscene = 1;
			break;
		case SDLK_DOWN:
			if (selected<songsdb.size()-1) selected++;
			if (selected>viewOffset+15) viewOffset++;
			break;
		case SDLK_UP:
			if (selected>0) selected--;
			if (selected<viewOffset) viewOffset--;
			break;
		case SDLK_PAGEDOWN:
			selected=selected+16;
			if (selected>=songsdb.size()) selected=songsdb.size()-1;
			if (selected>viewOffset+15) viewOffset=selected-15;
			break;
		case SDLK_PAGEUP:
			selected=selected-16;
			if (selected<0) selected=0;
			if (selected<viewOffset) viewOffset=selected;
			break;
		case SDLK_HOME:
			selected=0;
			viewOffset=0;
			break;
		case SDLK_END:
			selected=songsdb.size()-1;
			if (selected>viewOffset+15) viewOffset=selected-15;
			break;
		case SDLK_SPACE:
			if (previewlock!=selected) previewlock=selected;
			else previewlock=-1;
			break;
		case SDLK_RETURN:
			globals::selectedsong=songsdb[selected].dir;
			fadetoscene(SCN_SETSONGOPT);
			break;
		}
		break;
	}
	if (selected!=oldsel)
	{
		selecttime=scn.time;
	}
}
