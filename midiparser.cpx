interface

uses includes;

struct notestatus
{
	int timestamp;
	char stat[24]; // " O-XB"
	string otherstat;
};

typedef vector<vector<notestatus> > vvnotestatus;

class MidiParser
{
	unsigned char *buffer;
	int size;
	int fd;
	int pos;
	int savedpos;
	int nxmark;
	int chunkend,chunklen;
	int format;
	int tracks;
	int ticksperbeat;
	int ts_numer, ts_denom, ts_metro, ts_32nds;
	double tickduration;
	notestatus a;
	vector<notestatus> score;
protected:
	int FAIL;
	int expect(const char *str);
	int doparse();
	int isthere(const char *str);
	unsigned int readbyte();
	unsigned int readshort();
	unsigned int readlong();
	unsigned int readvarlen();
	void timeincrement(int delta);
public:
	vvnotestatus trk_notes;
	vector<int> trk_difficulties;
	vector<string> trk_instrument;

	int openfile(const char *name);
};

implementation

uses message,verbosity;

int MidiParser::expect(const char *str)
{
	if (!isthere(str))
	{
		WARN(MIDI,"Midi did not contain expected string:%s\n" &str);
		FAIL=1;
		return 0;
	}
	pos+=strlen(str);
	return 1;
}

int MidiParser::isthere(const char *str)
{
	int i;
	for (i=0; str[i]!=0; i++)
		if (buffer[pos+i]!=str[i]) return 0;
	return 1;
}

unsigned int MidiParser::readbyte()
{
	if (pos>=size) return 0;
	return buffer[pos++];
}

unsigned int MidiParser::readshort()
{
	unsigned int res;
	res =readbyte()*256;
	res+=readbyte();
	return res;
}

unsigned int MidiParser::readlong()
{
	unsigned int res;
	res =readshort()*65536;
	res+=readshort();
	return res;
}

unsigned int MidiParser::readvarlen()
{
	unsigned int res=0;
	unsigned char c;
	do {
		c=readbyte();
		res=res*128+(c&0x7f);
	} while (c&0x80);
	return res;
}


int MidiParser::openfile(const char *name)
{
	fd=open(name,O_RDONLY);
	if (fd<0) return 0;
	size=lseek(fd,0,SEEK_END);
	lseek(fd,0,SEEK_SET);
	if (size>10000000) 
	{
		WARN(MIDI,"Problem, midi file unreasonably big!!\n");
		close(fd);
		return 0;
	}
	buffer=new unsigned char[size];
	size=read(fd,buffer,size);
	INFO(READMID,"Read midi file of size %d\n" & size);
	pos=0;
	FAIL=0;
	int res=doparse();
	delete [] buffer;
	close(fd);
	return res;
}

string titleCase(string m)
{
	string res;
	int i=0;
	int noupcase=0;
	while (i<m.length() && isspace(m[i])) i++;
	for (;i<m.length(); i++)
	{
		if (noupcase && m[i]>='A' && m[i]<='Z') 
		{
			res+=m[i]-'A'+'a';
			continue;
		}
		if ((!noupcase) && m[i]>='a' && m[i]<='z') 
		{
			res+=m[i]-'a'+'A';
			continue;
		}
		if (isspace(m[i]))
		{
			res+=" ";
			noupcase=0;
			continue;
		}
		noupcase=1;
		res+=m[i];
	}
	return res;
}

string processInstrumentName(string m)
{
	int a=m.find("PART ");
	if (a!=string::npos) m=m.substr(a+5);
	string res=titleCase(m);
	if (res=="") return "Guitar";
	return res;
}

void MidiParser::timeincrement(int delta)
{
	int newtimestamp=a.timestamp+(int) (44100*tickduration*delta);
	DBG(READMID,"Time increment %5d,  1000ticks=%3.3fs, time is now %7.3fs    " 
		&delta &(tickduration*1000) &(newtimestamp/44100.0));
	score.push_back(a);
	a.timestamp=newtimestamp;
	int i;
	for (i=0; i<20; i++) switch (a.stat[i])
	{
		case 'O':
		case '-':
			a.stat[i]='-';
			break;
		
		default:
			a.stat[i]=' ';
	}
	a.otherstat="";
}

int MidiParser::doparse()
{
	if (isthere("RIFF"))
	{
		pos+=20;
		// this takes care of the most common RMI format
		// a proper parse of RIFF would be necessary only 
		// if such MIDs are encoutered
	}
	expect("MThd");
	assret(!FAIL,"bad header marker, MThd expected");
	chunklen=readlong();
	warnif(chunklen!=6, "Expecting header chunk of size 6, but was %d instead" & chunklen);
	savedpos=pos;
	format=readshort();
	tracks=readshort();
	unsigned int bp0,bp1;
	bp0=readbyte();
	bp1=readbyte();
	ticksperbeat=0;
	if (bp0 & 0x80) 
	{
		bp0 &= 0x7f;
		tickduration=bp0;
		if ((bp0 & 0x7f)==29) tickduration=30/1001.0;
		tickduration=1/tickduration/bp1;
		INFO(READMID,"Midi Tick fps:%d ticks/frame %d 1000ticks=%2.3fs\n" &bp0 &bp1 &(tickduration*1000));
	}
	else
	{
		ticksperbeat=bp0*256+bp1;
		tickduration=0.5f/ticksperbeat;
		// 120 bpm is standard if we get no other info
		INFO(READMID,"Midi ticks/beat %d  1000ticks=%2.3fs\n" &ticksperbeat &(tickduration*1000));
	}
	pos=savedpos+chunklen;
	assret(!FAIL,"Could not read entire header, probably end-of-file");
	assret(pos<size,"Header size sent us past end-of-file");
	INFO(READMID,"Midi file has %d tracks, format is %d\n" &tracks &format);
	savedpos=pos;
	trk_notes.resize(0);
	trk_difficulties.resize(0);
	trk_instrument.resize(0);
	while (tracks>0)
	{
		assret(expect("MTrk"),"Expecting track header");
		int tracksize=readlong();
		int lastcmd=0;
		INFO(READMID,"Track size is %d\n" &tracksize);
		assret(tracksize+savedpos+8<=size,"Track size exceeds end-of-file");
		chunkend=pos+tracksize;
		int anynotes=0;
		int difficulties=0;
		memset(a.stat,' ',sizeof(a.stat));
		a.timestamp=0;
		a.stat[21]=0;
		score.resize(0);
		string instrument="Guitar";
		while (pos<chunkend) 
		{
			unsigned int delta=readvarlen();
			unsigned int event=readbyte();
			if (! (event & 0x80))
			{
				assret(lastcmd>0,"running with no command");
				event=lastcmd;
				pos--;
			}
			unsigned int uspqn;
			if (delta) timeincrement(delta);
			else DBG(READMID,"                                                                 ");
			if (event==0xff)
			{
				int sub=readbyte();
				int len=readbyte(); // or readvariable, not sure which
				int aftermeta=pos+len;
				string message;
				switch (sub)
				{
				case 1:
				case 6:
				case 5:
				case 7:
					message=string((const char *) buffer+pos,len);
					INFO(READMID,"MIDI Text: %s\n" &message);
					break;
				case 2:
					message=string((const char *) buffer+pos,len);
					INFO(READMID,"MIDI Copyright: %s\n" &message);
					break;
				case 3:
					message=string((const char *) buffer+pos,len);
					instrument=processInstrumentName(message);
					INFO(READMID,"MIDI Track name: %s instrument %s\n" &message &instrument);
					break;
				case 4:
					message=string((const char *) buffer+pos,len);
					instrument=processInstrumentName(message);
					INFO(READMID,"MIDI Instrument name: %s instrument %s\n" &message &instrument);
					break;
				case 47:
					INFO(READMID,"MIDI End of track\n");
					pos=chunkend;
					break;
				
				case 81:
					uspqn=65536*readbyte();
					uspqn+=256*readbyte();
					uspqn+=readbyte();
					tickduration=uspqn/1000000.0/ticksperbeat;
					INFO(READMID,"MIDI Set tempo us/qnote %d, ticks/beat %d  1000ticks=%2.3fs\n" 
						&uspqn &ticksperbeat &(tickduration*1000));
					break;
				case 84:
					INFO(READMID,"MIDI End of track\n");
					break;
				case 88:
					ts_numer=readbyte();
					ts_denom=readbyte();
					ts_metro=readbyte();
					ts_32nds=readbyte();
					INFO(READMID,"MIDI time signature %d/%d-%d-%d\n" & ts_numer & ts_denom & ts_metro & ts_32nds);
					break;
				default:
					INFO(READMID,"MIDI Unknown meta event %d\n" &sub);
				}
				pos=aftermeta;
				//INFO(READMID,"MIDI skipping meta %x" &pos);
				continue;
			}
			lastcmd=event;
			int evhi=(event>>4) & 0x0f;
			unsigned int notenum,velo,ournote;
				
			switch (evhi)
			{
			case 8:
			case 9:
			case 10:
			case 11:
			case 14:
				notenum=readbyte();
				velo=readbyte();
				ournote=20;
				if (notenum>=60 && notenum<=64)  ournote=notenum-60;
				if (notenum>=72 && notenum<=76)  ournote=notenum-67;
				if (notenum>=84 && notenum<=88)  ournote=notenum-74;
				if (notenum>=96 && notenum<=100) ournote=notenum-81;
				break;
			case 12:
			case 13:
				readbyte();
				break;
			}
			if ((event & 0xf0)==0x90)
			{
				a.stat[ournote]='O';
				DBG(READMID,"MIDI note-on:  %4d %4d %s\n" & notenum & velo & a.stat);
				anynotes=1;
				if (a.timestamp>40000) difficulties |= 1<<(ournote/5);
				continue;
			}
			if ((event & 0xf0)==0x80)
			{
				if (a.stat[ournote]=='-' || a.stat[ournote]==' ') a.stat[ournote]='X';
				else a.stat[ournote]='B';
				DBG(READMID,"MIDI note-off: %4d %4d %s\n" & notenum & velo & a.stat);
				continue;
			}
			INFO(READMID,"Event %d 0x%02x, delta %d\n" &event &event &delta);
			
			break;
		}
		if (anynotes)
		{
			INFO(READMID,"MIDI Track had note events, time=%d\n" & (a.timestamp/44100));
			timeincrement(1);
			timeincrement(100000000);
			trk_notes.push_back(score);
			trk_difficulties.push_back(difficulties);
			trk_instrument.push_back(instrument);
		}
		pos=savedpos+tracksize+8;
		savedpos=pos;
		tracks--;
	}
	return 1;
}
