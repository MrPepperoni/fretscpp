/*******************************************************************
(C) 2011 by Radu Stefan
radu124@gmail.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*******************************************************************/  

interface

uses includes,player,confrw;

string configFile;
string scoresFile;
string homeconfdir;
string datadir;
// just decided namespaces are evil
// namespaces allow you to have two things with the same name
// why would you want that, just to create confusion?
// namespace config

// for selection of the neck we have the following variables
// the filename of the neck
string themeNeckfilename;
// the index in the list of necks 
int themeNeckidx;
// the config name of the neck: themeNeckname
vstring themeNecknames;
vstring themeNeckfilenames;
vstring themeStages;
vstring themesMainm;
vstring themesScore;
vstring themesSlist;
vstring themesSopts;
vstring themesSettm;

#define CONFIGLIST \
CONFIGITEM(GLfloat,neckpos_extend,0) \
CONFIGITEM(GLfloat,tolerance_early,120) \
CONFIGITEM(GLfloat,tolerance_late,120) \
CONFIGITEM(int,tappablemode,0) \
CONFIGITEM(int,strictkeys,0) \
CONFIGITEM(int,miss_loudness,200) \
CONFIGITEM(int,guitar_volume,100) \
CONFIGITEM(int,guitar_off_volume,20) \
CONFIGITEM(GLfloat,boardlen,4) \
CONFIGITEM(GLfloat,boardline,3) \
CONFIGITEM(GLfloat,necktop,2) \
CONFIGITEM(int,video_glflush,0) \
CONFIGITEM(int,video_glfinish,0) \
CONFIGITEM(int,video_dofullscreen,0) \
CONFIGITEM(int,video_overrideres,0) \
CONFIGITEM(int,scr_width,800) \
CONFIGITEM(int,scr_height,600) \
CONFIGITEM(string,themeStage,"rf-mod") \
CONFIGITEM(string,themeMainm,"default") \
CONFIGITEM(string,themeScore,"default") \
CONFIGITEM(string,themeSlist,"default") \
CONFIGITEM(string,themeSopts,"default") \
CONFIGITEM(string,themeSettm,"default") \
CONFIGITEM(string,themeNeckname,"Default") \
CONFIGITEM(int,themeNecktransparency,0) \
CONFIGARRAY(GLfloat,neckpos,.xdisp,.xdisp) \
CONFIGARRAY(GLfloat,neckpos,.ydisp,.ydisp) \
CONFIGARRAY(GLfloat,neckpos,.scale,.scale) \
CONFIGARRAY(GLfloat,neckpos,.stretch,.stretch) \
CONFIGARRAY(GLfloat,neckpos,.skew,.skew) \
CONFIGARRAY(int,neckpos,.statpos,.statpos) \
CONFIGARRAY(int,keydefs,.key[0],.fret1) \
CONFIGARRAY(int,keydefs,.key[1],.fret2) \
CONFIGARRAY(int,keydefs,.key[2],.fret3) \
CONFIGARRAY(int,keydefs,.key[3],.fret4) \
CONFIGARRAY(int,keydefs,.key[4],.fret5) \
CONFIGARRAY(int,keydefs,.key[5],.pick) \
CONFIGARRAY(int,keydefs,.key[6],.altpick) \
CONFIGARRAY(int,keydefs,.key[7],.whammy) \
CONFIGARRAY(int,keydefs,.key[8],.power) \
CONFIGARRAY(string,keyconfname,,) \


#define CI_DECLARE(a,b,c) a b=c;
#define CI_PRINT(a,b,c) { fprintf(fou,""#b" = "); CONFWRITE_##a(b); fprintf(fou,"\n"); }
#define CIA_PRINT(a,b,c,d) { int it; for (it=0; it<b.size(); it++) { fprintf(fou,""#b"[%d]"#d" = ",it); CONFWRITE_##a(b[it]c); fprintf(fou,"\n");} }

#define CI_READ(a,b,c) { if (tsimatch(p,""#b)) { confread_##a(p,b); } }
#define CIA_READ(a,b,c,d) { int idx; if (tsamatch(p,""#b,""#d,idx)) \
	{\
		assume(idx<1000,"Bad array index>1000"); \
		if (idx>=b.size()) b.resize(idx+1); \
		confread_##a(p,b[idx]c); \
	}\
}

/*******************************************************
 * Automatic generation of config variable declarations
 */
#define CONFIGITEM CI_DECLARE
#define CONFIGARRAY(a,b,c,d)
CONFIGLIST
#undef CONFIGARRAY
#undef CONFIGITEM


struct tKeydefset
{
	int key[9];
};

vector<tKeydefset> keydefs;
vstring keyconfname;
int video_vsync;
int video_limiter;
GLfloat video_fpslim;


struct tNeckpos
{
	GLfloat xdisp,ydisp;
	GLfloat scale,stretch;
	GLfloat skew;
	int statpos;
//	tNeckpos():xdisp(0),ydisp(0),scale(1),stretch(1),skew(0),statpos(0) {;}
};
	
// bit mask describing the last selected input devices
//we don't expect more than 8 players
long keydefselector[8];
void init_config();

int conf_stretch=0;
const int NECKPOS_COUNT=MAX_PLAYERS*(MAX_PLAYERS+1)/2+1;
vector<tNeckpos> neckpos;
vector<string> config_unknown;

tNeckpos defneckpos[11]={
{0.000,0.000,1.000,1.000,0.000,0},
{-3.250,0.000,1.000,0.700,-0.220,0},
{3.250,0.000,1.000,0.700,0.220,0},
{-3.500,-0.250,0.800,0.600,-0.150,0},
{0.000,2.250,0.900,0.500,0.000,0},
{3.500,-0.250,0.800,0.600,0.150,1},
{-3.000,-1.250,0.700,1.000,0.020,0},
{-2.250,2.500,0.900,0.500,-0.310,0},
{2.250,2.500,0.900,0.500,0.310,1},
{3.500,-1.250,0.700,1.000,-0.030,1},
{2.000,0.000,1.000,0.900,0.000,1}
};

int enablehopos;
const char *difficultynames[4]={"SuperE","Easy","Medium","Hard"};

/***********************************************
 * Match configuration string against pattern
 * and increment pointer if match occurred
 */
int tsimatch(char *&s, const char *v);
int tsamatch(char *&s, const char *prefix, const char *suffix, int &idx);

implementation

uses fileio, scnSetTheme, video;

int tsimatch(char *&s, const char *v)
{
	int l=strlen(v);
	if (0!=strncmp(s,v,l)) return 0;
	char ch=s[l];
	if (ch!='=' && ch!=' ' && ch!='\t') return 0;
	s+=l;
	while (*s==' ' || *s=='\t' || *s=='=') s++;
	DBG(CONFIG, "Matched id: %s" ,v);
	return 1;
}

int tsamatch(char *&s, const char *prefix, const char *suffix, int &idx)
{
	char *ss=s;
	int idxv;
	int l=strlen(prefix);
	if (0!=strncmp(s,prefix,l)) return 0;
	ss+=l;
	if (*ss!='[') return 0;
	idxv=0;
	ss++;
	while (*ss>='0' && *ss<='9') 
	{
		idxv=idxv*10+*ss-'0';
		ss++;
	}
	if (*ss!=']')
	{
		WARN(CONFIG,"Config: expecting ]");
		return 0;
	}
	ss++;
	l=strlen(suffix);
	if (l!=0 && 0!=strncmp(ss,suffix,l)) return 0;
	ss+=l;
	if (*ss!='=' && *ss!=' ' && *ss!='\t') return 0;
	while (*ss==' ' || *ss=='\t' || *ss=='=') ss++;
	idx=idxv;	
	s=ss;
	DBG(CONFIG, "Matched array: %s[%d]%s" ,prefix ,idx ,suffix);
	return 1;
}

int defkeys[]={ SDLK_F1, SDLK_F2, SDLK_F3, SDLK_F4, SDLK_F5, SDLK_RETURN, SDLK_RSHIFT, SDLK_TAB, 'p'};
int defkey2[]={ '1','2','3','4','5','k','m','l','p' };

int config_read()
{
	char line[1024];
	int i, j, v, numkeys;
	FILE *fc=fopen(configFile.c_str(),"r");
	if (!fc) return 0;
	// ini namespace marked with [ ]
	string nsp="";
	while (!feof(fc))
	{
		fgets(line,999,fc);
		char *p, *sav;
		// eliminate CR,LF at the end of line
		p=line+strlen(line)-1;
		while (p>=line) 
		{
			if (*p!=10 && *p!=13) break;
			*p=0;
		}
		p=line;
		while (*p==' ' || *p=='\t') p++;
		if (*p=='[')
		{
			sav=++p;
			while (*p!=']' && *p) p++;
			*p=0;
			nsp=sav;
			DBG(CONFIG,"Config namespace: %s\n" ,nsp);
			continue;
		}
		if (*p==';')
			continue;
		// anything outside [fretscpp] is ignored
		if (nsp!="fretscpp") continue;
		sav=p;
		DBG(CONFIG,"CONFIG: %s %s\n" ,nsp ,p);
#define CONFIGITEM CI_READ
#define CONFIGARRAY CIA_READ
CONFIGLIST
#undef CONFIGARRAY
#undef CONFIGITEM
		if (sav==p) config_unknown.push_back(sav);
	}
	fclose(fc);
	if (numkeys<2) return 0;
	return 1;
}

void config_write()
{
	int i,j;
	FILE *fou=fopen(configFile.c_str(),"w");
	if (!fou) return;
	fprintf(fou,"[fretscpp]\n");
#define CONFIGITEM CI_PRINT
#define CONFIGARRAY CIA_PRINT
CONFIGLIST
#undef CONFIGARRAY
#undef CONFIGITEM
	if (config_unknown.size()) fprintf(fou,"; unknown entries");
	for (i=0; i<config_unknown.size(); i++)
		fprintf(fou,"%s\n",config_unknown[i].c_str());
	fclose(fou);
}

void config_defaults()
{
	int i;
	keydefs.resize(0); // make sure it's clear
	keydefs.resize(2);
	keyconfname.resize(0);
	keyconfname.push_back("Keyboard");
	keyconfname.push_back("Keyb#2");
	for (i=0; i<9; i++) 
	{
		keydefs[0].key[i]=defkeys[i];
		keydefs[1].key[i]=defkey2[i];
	}
	keydefselector[0]=1;
	keydefselector[1]=2;
	neckpos.resize(11);
	for (i=0; i<11; i++) neckpos[i]=defneckpos[i];
}

void config_fix()
{
	keyconfname.resize(keydefs.size());
}

void trydatadir(string td)
{
	if (datadir!="") return;
	MESSAGE("Looking for game data in: %s\n", td);
	if (fileExists(td+"/default.ttf"))
	{
		datadir=td;
		MESSAGE("found!\n");
	}
}

void init_config()
{
	int i;
	//findvideomodes();
	
#ifdef _WINDOWS
	_TCHAR homefolder[MAX_PATH];
	configFile="fretscpp.ini";
	homeconfdir="";
	i=SHGetFolderPath(NULL,CSIDL_PERSONAL,NULL,0/*SHGFP_TYPE_CURRENT*/,homefolder);
	if (i!=S_OK) MESSAGE("Could not get home folder\n");
	else homeconfdir=string(homefolder)+"/fretscpp";
	CreateDirectory(homeconfdir.c_str(),NULL);
	datadir="";
#else
	homeconfdir=getenv("HOME");
	homeconfdir+="/.config/fretscpp";
	uu=system((string("mkdir -p ")+homeconfdir).c_str());
#endif
	configFile=homeconfdir+"/fretscpp.ini";
	scoresFile=homeconfdir+"/scores.txt";
	trydatadir(homeconfdir+"/data");
	trydatadir("./data");
	trydatadir("/usr/share/games/fretscpp/data");
	trydatadir("/usr/local/share/games/fretscpp/data");
	trydatadir("/usr/share/games/fretsonfire/data");
	config_defaults();
	config_read();
	config_fix();
	theme_init();
}
