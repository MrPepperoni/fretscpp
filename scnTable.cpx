interface

uses includes, verbosity, scene;

class tScnTable:public sceneBase
{
public:
	tScnTable();
	GLfloat fadespeed() { return 100; }
	void render();
	void rendertext();
	void enter();
	void handleevent(SDL_Event &a);
	virtual void itemClicked(int i, int j=0) {;}
	
	void additem(string s);
	void selfix();
	void optinit();
	void newcol();
	void cleancol();
	void dupcol();
	void makeempty();
	char getMarker(int i, int j); // first letter of title
	void touch(int i, int j);
	
	int lastlr; // 0=left
	int lastud; // 0=up
	vvstring entries;
	vvint opt;
	int selx, sely;
	int baseh;
	GLfloat colsize;
	GLfloat xpos;
	int colsvisible;
	int fixedcols;
	int mustregenopt;
	
};

implementation

uses songsdb,sprites,audio;

tScnTable::tScnTable()
{
	selx=0;
	sely=0;
	baseh=0;
	fixedcols=0;
	xpos=20;
	colsvisible=2;
	mustregenopt=0;
}

void tScnTable::additem(string s)
{
	if (!entries.size()) entries.resize(1);
	entries.back().push_back(s);
	mustregenopt=1;
}

void tScnTable::cleancol()
{
	if (!entries.size()) entries.resize(1);
	entries.back().resize(0);
	mustregenopt=1;
}

void tScnTable::newcol()
{
	entries.push_back(vstring());
	mustregenopt=1;
}

void tScnTable::dupcol()
{
	entries.push_back(entries.back());
	mustregenopt=1;
}

void tScnTable::makeempty()
{
	entries.resize(0);
	mustregenopt=1;
}


void tScnTable::enter()
{
	SDL_EnableKeyRepeat(133,33);
}

void tScnTable::optinit()
{
	int i;
	mustregenopt=0;
	opt.resize(0);
	opt.resize(entries.size());
	for (i=0; i<entries.size(); i++)
		if (opt[i].size()!=entries[i].size())
			opt[i].resize(entries[i].size());
	
}

char tScnTable::getMarker(int selx, int sely)
{
	char c;
	if (opt[selx][sely] & 2) return '|';
	if (entries[selx][sely]=="") c='|';
		else c=entries[selx][sely][0]; 
	return c;
}

void tScnTable::selfix()
{
	int i,steps=0;
	if (opt.size()!=entries.size()) optinit();
	while (1)
	{
		steps++;
		if (steps>100)
		{
			//avoid looping forever
			selx=0;
			sely=0;
			baseh=0;
			return;
		}
		if (selx<0) { selx=0; lastlr=1; continue; }
		if (selx>=entries.size()) { selx=entries.size()-1; lastlr=-1; continue; }
		if (sely<0) { sely=0; lastud=1; continue; }
		if (sely>=entries[selx].size()) { sely=entries[selx].size()-1; lastud=-1; continue; }
		//if (xpos<baseh) baseh=xpos;
		//if (xpos>=baseh+colsvisible) baseh=xpos-colsvisible+1;
		switch (getMarker(selx,sely))
		{
		case 'O':
		case 'A':
		case 'B':
		case 'C':
		case 'E':
		case 'F':
		case 'X':
		case 'Y':
			return;
		case '|':
			sely+=lastud;
			continue;
		case '-':
			selx+=lastlr;
			continue;
		case '<':
			selx--;
			continue;
		case '>':
			selx++;
			continue;
		case 'V':
			sely++;
			continue;
		case '^':
			sely--;
			continue;
		}
	}
}

void tScnTable::rendertext()
{
	if (mustregenopt) optinit();

	int i,j,cc;
	GLfloat x,y,scale;
	colsize=(w-xpos*2)/colsvisible;
	scale=h*0.05;
	glLoadIdentity();
			
	for (j=0; j<fixedcols+colsvisible; j++)
	{
		if (j<fixedcols) cc=j;
		else cc=j-fixedcols+baseh;
		y=2*scale;
		x=scale+colsize*j;
		if (cc>=entries.size()) continue;
		for (i=0; i<entries[cc].size(); i++)
		{
			string item=entries[j][i];
			
			if (item=="") 
			{
				y+=scale/2;
				continue;
			}
			if (opt[j][i] & 2) continue;
				
			glColor3f(0.0f,0.0f,0.0f);
			GLfloat dy=0;
			
			if (selx==j && sely==i && scn.fade==0)
			{
				dy=sin(scn.time*8)*scale*0.1;
				if (opt[j][i] & 1) glColor3f(1.0f,0.1f,0.0f);
				else glColor3f(1.0f,0.7f,0.0f);
			}
			else  
			{
				if (opt[j][i] & 1) glColor3f(0.9f,0.0f,0.0f);	
				else glColor3f(0.8f,0.3f,0.0f);	
			}
			
			deffont.displayString(item.c_str()+1, x, y+dy ,scale);
			y+=scale;
		}
	}
}

void tScnTable::touch(int i, int j)
{
	char c=getMarker(i,j);
	//printf("%d %d %c\n",i,j,c);
	int q;
	switch (c)
	{
	case 'O':
		itemClicked(i,j);
		break;
	case 'Q':
		itemClicked(-1,-1);
		break;
	case 'A':
	case 'B':
		// these work like radio buttons
		for (q=0; q<entries[i].size(); q++)
			if (getMarker(i,q)==c) opt[i][q]=0;
		opt[i][j]=1;
		itemClicked(i,j);
		break;
	case 'C':
		opt[i][j]^=1;
		itemClicked(i,j);
		break;
	}
}

void tScnTable::handleevent(SDL_Event &event)
{
	int actkey;
	if (mustregenopt) optinit();
	switch (event.type)
	{
	case SDL_KEYDOWN:
		actkey=event.key.keysym.sym;
		// may need to process this one to intercept other keys
		switch (actkey) 
		{
		case SDLK_ESCAPE:
			itemClicked(-1,-1);
			break;
		case SDLK_DOWN:
			lastud=1;
			sely++;
			break;
		case SDLK_UP:
			lastud=-1;
			sely--;
			break;
		case SDLK_RIGHT:
			lastlr=1;
			selx++;
			break;
		case SDLK_LEFT:
			lastlr=-1;
			selx--;
			break;
		case SDLK_END:
		case SDLK_PAGEDOWN:
			lastud=1;
			sely=entries[selx].size()-1;
			break;
		case SDLK_HOME:
		case SDLK_PAGEUP:
			lastud=-1;
			sely=0;
			break;
		case SDLK_SPACE:
		case SDLK_RETURN:
			touch(selx, sely);
			break;
		}
		break;
	}
	selfix();
}

void tScnTable::render()
{
	paintrotback();
	rendertext();
}

