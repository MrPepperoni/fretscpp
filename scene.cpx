/*******************************************************************
(C) 2010 by Radu Stefan
radu124@gmail.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*******************************************************************/  
  
interface

uses includes;

enum ENUM_SCENES { SCN_NULL=0, SCN_MAINMENU=1, SCN_SONGS=2, SCN_SETSONGOPT=3, SCN_PLAYING=4, SCN_KEYDEF, SCN_SCORE};

class sceneBase
{
public:
	virtual void render()=0;
	void setdim();
	virtual void handleevent(SDL_Event &a)=0;
	virtual GLfloat fadespeed() { return 0.6; }
	virtual void enter() {;}
	virtual void leave() {;}
	GLfloat w,h,ms,t;
	void paintrotback();
};

struct tscene
{
	GLfloat fade;
	GLfloat menufade;
	GLfloat time;
	double timestartsc;
	GLfloat timesc;
	GLfloat timestartfade;
	int current;
	int prevscene;
	int nextscene;
} scn;

void renderscene();
void scenehandleevent(SDL_Event &ev);
void jumptoscene(int i);
void fadetoscene(int i);

GLfloat camerapos[3]={0,-4,3};
GLfloat cameraangle=30;

class tscenelist
{
public:
	static vector<sceneBase*> & get()
	{
		static vector<sceneBase*> res;
		return res;
	}
	void add(sceneBase *s, int idx)
	{
		if (idx>=get().size()) get().resize(idx+1);
		get()[idx]=s;
	}
	int add(sceneBase *s)
	{
		get().push_back(s);
		return get().size()-1;
	}
	sceneBase * operator [] (int i);
};

void scene_setOrtho();
void scene_setNeck(int i=0);

tscenelist scenes;

implementation

uses scnMainMenu,message,scnSongs,scnMenu,globals,scnSetSongOpt,scnGuitar,scnScore;

void scene_setOrtho()
{
	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	glOrtho(0.0f, globals::scr_width, globals::scr_height, 0.0f, -1.0f, 1.0f);
	glMatrixMode( GL_MODELVIEW );
	glLoadIdentity();
}

GLfloat sskewmatrix[16]={
	1,0,0,0,
	0,1,0,0,
	0,0,1,0,
	0,0,0,1};

void scene_setNeck(int i)
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(90.0f, 1.0f * globals::scr_width / globals::scr_height, 1.0f, 100.0f);
	gluLookAt(
		camerapos[0], camerapos[1], camerapos[2],
		0.0f, 0.0f, 0.0f,
		0.0f, 0.0f, 1.0f);
	//glLoadIdentity();
	
	//float fvViewMatrix[ 16 ]; 
	//glGetFloatv( GL_MODELVIEW_MATRIX, fvViewMatrix );
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	if (globals::numplayers!=1)
	{
		glTranslatef(-1.5+3*i,0,0);
		glScalef(0.5,0.7,1);
		sskewmatrix[4]=-0.4+i*0.8;
		sskewmatrix[12]=i*3-1.5;
		sskewmatrix[8]=0.1-0.2*i;
		// ok, there are more ways of doing it, i like it like this
		//sskewmatrix[8]=0.8-1.6*i;
		glMultMatrixf(sskewmatrix);
	}
}

void sceneBase::setdim()
{
	w=globals::scr_width;
	h=globals::scr_height;
	ms=w/640.0;
	t=scn.timesc*0.33;
}

void sceneBase::paintrotback()
{
	setdim();
	glClearColor( 0.3f, 0.0f, 0.0f, 0.0f );
	glClear( GL_COLOR_BUFFER_BIT );	
	glLoadIdentity();
	// v*2*w+
	glTranslatef(0.5*w+cos(t/2)*w*0.2, 0.5*h+sin(t)*w*0.2, 0);
	glRotatef(t*53.3f+30,0.0,0.0,1.0);
	glScalef(2+sin(t/8), 2+sin(t/8),1.0);
	glScalef(ms,ms,1.0);
	spc.back.draw();
}

void fadetoscene(int i)
{
	scn.nextscene=i;
}

void jumptoscene(int i)
{
	scn.nextscene=i;
	scn.prevscene=0;
}

sceneBase * tscenelist::operator [] (int i)
{
	assume(i>=0 && i<get().size(),"bad scene %d" &i);
	return get()[i];
}

GLfloat fadespeed(int scene)
{
	if (!scenes[scene])
		return 0.6;
	return scenes[scene]->fadespeed();
}

void scenehandleevent(SDL_Event &event)
{
	SDL_Event e=event;
	// perform translation before sending to scene
	if (e.type==SDL_JOYBUTTONDOWN)
	{
		e.type=SDL_KEYDOWN;
		e.key.keysym.sym=(SDLKey) (1000000+256*e.jbutton.which+e.jbutton.button);
	}
	if (e.type==SDL_JOYBUTTONUP)
	{
		e.type=SDL_KEYUP;
		e.key.keysym.sym=(SDLKey) (1000000+256*e.jbutton.which+e.jbutton.button);
	}
	if (!scenes[scn.current]) return;
	scenes[scn.current]->handleevent(e);
}

void renderscene()
{
	// ensure no leftovers
	glBindTexture(GL_TEXTURE_2D,NULL);
	glLoadIdentity();
	
	scn.time=gettimenow();
	int crtdispscene=scn.current;
	if (scn.nextscene)
	{
		scenes[scn.current]->leave();
		scn.prevscene=scn.current;
		scn.current=scn.nextscene;
		scn.nextscene=0;
		scn.timestartfade=scn.time;
		scenes[scn.current]->enter();
	}
	if (scn.prevscene)
	{
		scn.fade=(scn.time-scn.timestartfade)*fadespeed(scn.prevscene);
		if (scn.fade>1)
		{
			scn.prevscene=0;
			scn.timestartfade=scn.time;
		}
		else crtdispscene=scn.prevscene;
	} else {		
		scn.fade=1-(scn.time-scn.timestartfade)*fadespeed(scn.current);
		if (scn.fade<0) scn.fade=0;
		else scn.timestartsc=scn.time;
	}
	scn.timesc=scn.time-scn.timestartsc;
	
	if (!scenes[crtdispscene])
	{
		// bootstrap
		scn.current=SCN_MAINMENU;
		scn.timestartfade=scn.time;
	}
	else scenes[crtdispscene]->render();
}
