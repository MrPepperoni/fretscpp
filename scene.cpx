interface

uses includes;

enum ENUM_SCENES { SCN_NULL=0, SCN_MAINMENU=1, SCN_SONGS=2, SCN_SETSONGOPT=3, SCN_PLAYING=4, SCN_KEYDEF};

class sceneBase
{
public:
	virtual void render()=0;
	void setdim();
	virtual void handleevent(SDL_Event &a)=0;
	virtual GLfloat fadespeed() { return 0.6; }
	virtual void enter() {;}
	virtual void leave() {;}
	GLfloat w,h,ms,t;
	void paintrotback();
};

struct tscene
{
	GLfloat fade;
	GLfloat menufade;
	GLfloat time;
	double timestartsc;
	GLfloat timesc;
	GLfloat timestartfade;
	int current;
	int prevscene;
	int nextscene;
} scn;

void renderscene();
void scenehandleevent(SDL_Event &ev);
void jumptoscene(int i);
void fadetoscene(int i);

class tscenelist
{
public:
	static vector<sceneBase*> & get()
	{
		static vector<sceneBase*> res;
		return res;
	}
	void add(sceneBase *s, int idx)
	{
		if (idx>=get().size()) get().resize(idx+1);
		get()[idx]=s;
	}
	int add(sceneBase *s)
	{
		get().push_back(s);
		return get().size()-1;
	}
	sceneBase * operator [] (int i);
};

tscenelist scenes;

implementation

uses scnMainMenu,message,scnSongs,scnMenu,globals,scnSetSongOpt,scnGuitar;

void sceneBase::setdim()
{
	w=globals::scr_width;
	h=globals::scr_height;
	ms=w/640.0;
	t=scn.timesc*0.33;
}

void sceneBase::paintrotback()
{
	setdim();
	glClearColor( 0.3f, 0.0f, 0.0f, 0.0f );
	glClear( GL_COLOR_BUFFER_BIT );	
	glLoadIdentity();
	// v*2*w+
	glTranslatef(0.5*w+cos(t/2)*w*0.2, 0.5*h+sin(t)*w*0.2, 0);
	glRotatef(t*53.3f+30,0.0,0.0,1.0);
	glScalef(2+sin(t/8), 2+sin(t/8),1.0);
	glScalef(ms,ms,1.0);
	spc.back.draw();
}

void fadetoscene(int i)
{
	scn.nextscene=i;
}

void jumptoscene(int i)
{
	scn.nextscene=i;
	scn.prevscene=0;
}

sceneBase * tscenelist::operator [] (int i)
{
	assume(i>=0 && i<get().size(),"bad scene %d" &i);
	return get()[i];
}

GLfloat fadespeed(int scene)
{
	if (!scenes[scene])
		return 0.6;
	return scenes[scene]->fadespeed();
}

void scenehandleevent(SDL_Event &event)
{
	if (!scenes[scn.current]) return;
	scenes[scn.current]->handleevent(event);
}

void renderscene()
{
	// ensure no leftovers
	glBindTexture(GL_TEXTURE_2D,NULL);
	glLoadIdentity();
	
	scn.time=gettimenow();
	int crtdispscene=scn.current;
	if (scn.nextscene)
	{
		scenes[scn.current]->leave();
		scn.prevscene=scn.current;
		scn.current=scn.nextscene;
		scn.nextscene=0;
		scn.timestartfade=scn.time;
		scenes[scn.current]->enter();
	}
	if (scn.prevscene)
	{
		scn.fade=(scn.time-scn.timestartfade)*fadespeed(scn.prevscene);
		if (scn.fade>1)
		{
			scn.prevscene=0;
			scn.timestartfade=scn.time;
		}
		else crtdispscene=scn.prevscene;
	} else {		
		scn.fade=1-(scn.time-scn.timestartfade)*fadespeed(scn.current);
		if (scn.fade<0) scn.fade=0;
		else scn.timestartsc=scn.time;
	}
	scn.timesc=scn.time-scn.timestartsc;
	
	if (!scenes[crtdispscene])
	{
		// bootstrap
		scn.current=SCN_MAINMENU;
		scn.timestartfade=scn.time;
	}
	else scenes[crtdispscene]->render();
}
