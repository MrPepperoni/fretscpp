interface

void init_audio();
int load_effects(char *fn);
int song_start(const char *path);
void song_stop();
void audio_yield();
double song_time();
void effect_start(int effnum, int channel=0, int volume=256);

int callbacklen;
SDL_AudioSpec desired, obtained;

implementation

uses verbosity, message;

struct tEffects
{
	int count;
	int16_t *data[256];
	int len[256];
	tEffects():count(0) { int i; for (i=0; i<256; i++) {data[i]=NULL; len[i]=0; } }
};

const int SONG_BUFFER_SIZE=262144;
const int SONG_MARGIN=16384;
const int SONG_STARTAFTER=44100;

struct tPlaying
{
	int effectid[8];
	int effectvol[8];
	int effectchn[8];
	int effectpos[8];
	
	volatile int gp0;
	volatile int playpos;
	volatile int decodepos[3];
	volatile int refreshsong;
	volatile int loopsong;
	volatile int playing;
	volatile int pause;
	volatile int songstarted;
	int ogg_bs[3];
	int decode_lasttime;
	int decode_ticks;
	OggVorbis_File ov_song;
	OggVorbis_File ov_rhythm;
	OggVorbis_File ov_guitar;
	volatile int ov_openflags;
	
	int16_t buffer[6][SONG_BUFFER_SIZE];
	char songname[2048];
	void close_song();
	void open_song();
	void some_predecode();
	void close_ovfile(int mask, OggVorbis_File *ovf);
	int decode(int idx, OggVorbis_File *ovf);
};

tEffects effects;
tPlaying playing;
const int BUF_SIZE=1024;
int mixbuffer_l[BUF_SIZE];
int mixbuffer_r[BUF_SIZE];

int pbpos=0;

int min3(int a, int b, int c)
{
	if (a<b && a<c) return a;
	if (b<c) return b;
	return c;
}

int rangelimit(int a)
{
	if (a<-32760) return -32760;
	if (a>32760) return 32760;
	return a;
}

void my_audio_callback(void *userdata, Uint8 *stream, int len)
{
	int i,da,db,dc;
	int16_t *streamS=(int16_t *) stream;
	int ov_of=playing.ov_openflags;
	int pos=playing.playpos%SONG_BUFFER_SIZE;
	callbacklen=len;
	//if (effects.len[0])
	da=playing.decodepos[0]; if (!(ov_of &1)) da=playing.playpos+SONG_STARTAFTER+1;
	db=playing.decodepos[1]; if (!(ov_of &2)) db=playing.playpos+SONG_STARTAFTER+1;
	dc=playing.decodepos[2]; if (!(ov_of &4)) dc=playing.playpos+SONG_STARTAFTER+1;
	int decodebtm=min3(da,db,dc);
	if (!playing.playing && decodebtm>playing.playpos+SONG_STARTAFTER) playing.playing=1;
	if (!ov_of) playing.playing=0;
	int en_play=(playing.playing && decodebtm>playing.playpos+len/4);
	if (!en_play) 
	{
		playing.playing=0;
		DBG(AUDIO,"P\n");
	}
	int vol1, vol2, vol3;
	int16_t *effs[8];
	int16_t *eff0=NULL;
	int16_t *eff1=NULL;
	int vole0=85;
	int vole1=85;
	vol1=vol2=85;
	vol3=playing.gp0*200+20;
	if (!(ov_of &1)) vol1=0;
	if (!(ov_of &2)) vol2=0;
	if (!(ov_of &4)) vol3=0;
	
	for (i=0; i<8; i++)
	{
		effs[i]=NULL;
		if (playing.effectid[i]>0)
		{
			int eid=playing.effectid[i];
			int epos=playing.effectpos[i];
			if (effects.len[eid]<epos+len/4) 
			{	
				playing.effectid[i]=0;
			} else effs[i]=effects.data[eid]+epos;
			playing.effectpos[i]+=len/4;
		}
	}
	eff0=effs[0];
	eff1=effs[1];
	/*
	DBG(AUDIO,"%8x %8x %8x %8x\n" &playing.playpos
		&(-playing.playpos+playing.decodepos[0])
		&(-playing.playpos+playing.decodepos[1])
		&(-playing.playpos+playing.decodepos[2])
		);
	*/
	if (playing.pause) en_play=0;
	for (i=0; i<len/4; i++)
	{
		int s=0;
		if (en_play)
		{
			s+=vol1*playing.buffer[0][pos];
			s+=vol2*playing.buffer[2][pos];
			s+=vol3*playing.buffer[4][pos];
		}
		if (eff0) s+=vole0* *eff0;
		if (eff1) s+=vole0* *eff1;
		streamS[i*2]=rangelimit(s/256);
		
		s=0;
	
		if (en_play)
		{
			s+=vol1*playing.buffer[1][pos];
			s+=vol2*playing.buffer[3][pos];
			s+=vol3*playing.buffer[5][pos];
		}
		if (eff0) s+=vole0* *eff0++;
		if (eff1) s+=vole0* *eff1++;
		streamS[i*2+1]=rangelimit(s/256);
		
		pos=(pos+1)%SONG_BUFFER_SIZE;
		//effects.data[0][pbpos];
		//pbpos=pbpos+1;
		//if (pbpos>=effects.len[0]) pbpos=0;
	}
	if (en_play)
		playing.playpos+=len/4;
	// warning, thread sync problem
}

void effect_start(int effnum, int channel, int volume)
{
	static int alternate=0;
	if (!effnum) return;
	playing.effectpos[alternate]=0;
	playing.effectid[alternate]=effnum;
	alternate^=1;
}

void init_audio()
{
	desired.freq=44100;
	desired.format=AUDIO_S16SYS;
	desired.samples=BUF_SIZE;
	desired.channels=2;
	desired.userdata=(void *) &playing;
	desired.callback=my_audio_callback;
	assume(SDL_OpenAudio(&desired, &obtained)>=0, "Couldn't open audio: %s\n");
	SDL_PauseAudio(0);
}

int16_t interpolate(int16_t *buf, int pos, int chn=1)
{
	return buf[pos/256];
}

int load_effects(const char *fn)
{
	int16_t buf[4112];
	int bs=0;
	int i,j,v;
	int pos=0,readpos;
	int allocd=220500;
	
	OggVorbis_File vf;
	if(ov_fopen((char *) fn, &vf) < 0) return 0;
	int channels = ov_info(&vf,0)->channels;
	int samplerate = ov_info(&vf,0)->rate;
	int cnt=effects.count;
	INFO(AUDIO,"OGG load effect %d: chn:%d, rate=%d\n" &cnt &channels &samplerate);
	buf[0]=buf[1]=0;
	dorealloc(effects.data[cnt],allocd);
	readpos=256;
	while (1)
	{
		int ret=ov_read(&vf,(char *)(buf+2),8192,0,2,1,&bs);
		if (!ret) break;
		int locchn=ov_info(&vf,-1)->channels;
		int locrate=ov_info(&vf,-1)->rate;
		int samples=ret/2/locchn;
		int step=locrate*256/obtained.freq;
		DBG(AUDIO,"Read %d chn:%d sr:%d\n" &samples &locchn &locrate);
		for (i=0; i<samples; i++)
		{
			v=0;
			for (j=0; j<locchn; j++) v+=buf[2+i*locchn+j];
			v=v/locchn;
			buf[2+i]=(int16_t) v;
		}
		while (readpos<(samples+1)*256)
		{
			readpos+=step;
			if (pos>=allocd)
			{
				allocd=allocd*2;
				dorealloc(effects.data[cnt],allocd);
			}
			effects.data[cnt][pos++]=interpolate(buf,readpos);
		}
		readpos-=samples*256;
		buf[0]=buf[samples];
		buf[1]=buf[samples+1];
	}
	dorealloc(effects.data[cnt],pos);
	INFO(AUDIO,"Loaded effect, len=%d\n" &pos);
	effects.len[cnt]=pos;
	ov_clear(&vf);
	return ++effects.count;
}

int song_start(const char *path)
{
	playing.gp0=1;
	strncpy(playing.songname,path,2047);
	playing.songname[2048]=0;
	playing.refreshsong=1;
	// need some thread protection here, in case we read this string at the same time
	// (unlikely, but just to be thorough)
}

void song_stop()
{
	playing.songname[0]=0;
	playing.refreshsong=1;
}

void tPlaying::close_song()
{
	decodepos[0]=decodepos[1]=decodepos[2]=0;
	playing=0;
	if (ov_openflags & 1) ov_clear(&ov_song);
	if (ov_openflags & 2) ov_clear(&ov_rhythm);
	if (ov_openflags & 4) ov_clear(&ov_guitar);
	ov_openflags=0;
}

void tPlaying::open_song()
{
	char namelocal[2148];
	strncpy(namelocal,songname,2048);
	namelocal[2048]=0;
	decodepos[0]=decodepos[1]=decodepos[2]=0;
	ogg_bs[0]=ogg_bs[1]=ogg_bs[2]=0;
	SDL_LockAudio();
	playpos=0;
	pause=0;
	SDL_UnlockAudio();
	songstarted=0;
	int l=strlen(namelocal);
	if (!l) return;
	if (namelocal[l-1]=='/') strcat(namelocal,"song.ogg");
	if (ov_fopen(namelocal, &ov_song) >=0) ov_openflags |= 1;
	if (namelocal[l-1]!='/') return;
	namelocal[l]=0;
	strcat(namelocal,"rhythm.ogg");
	if (ov_fopen(namelocal, &ov_rhythm) >=0) ov_openflags |= 2;
	namelocal[l]=0;
	strcat(namelocal,"guitar.ogg");
	if (ov_fopen(namelocal, &ov_guitar) >=0) ov_openflags |= 4;
	
}

int tPlaying::decode(int idx, OggVorbis_File *ovf)
{
	int i;
	int16_t buf[4112];
	int target=4096;
	int target2=decode_ticks*obtained.freq/250;
	if (target2>target) target=target2; 
	// decode at least 4 times as much as it took to render one frame
	int target3=SONG_BUFFER_SIZE-SONG_MARGIN-(decodepos[idx]-playpos);
	if (target3<target) target=target3; 
	DBG(AUDIO,"Filling buffer %d, targets are: %d %d %d\n" &idx &target &target2 &target3);
	int pos=decodepos[idx];
	while (target>0)
	{
		int ret=ov_read(ovf,(char *)buf,8192,0,2,1,&ogg_bs[idx]);
		if (!ret) return 1;
		
		int locchn=ov_info(ovf,-1)->channels;
		int locrate=ov_info(ovf,-1)->rate;
		int samples=ret/2/locchn;
		int chn2=locchn>1?1:0;
		
		DBG(AUDIO,"Read (idx %d) %d chn:%d sr:%d\n" &idx &samples &locchn &locrate);
		for (i=0; i<samples; i++)
		{
			buffer[idx*2  ][pos%SONG_BUFFER_SIZE]=buf[i*locchn];
			buffer[idx*2+1][pos%SONG_BUFFER_SIZE]=buf[i*locchn+chn2];
			pos++;
		}
		decodepos[idx]=pos;
		target-=samples;
	}
	return 0;
}

void tPlaying::close_ovfile(int mask, OggVorbis_File *ovf)
{
	ov_clear(ovf);
	ov_openflags &= ~mask;
}

void tPlaying::some_predecode()
{
	int thistime=SDL_GetTicks();
	decode_ticks=thistime-decode_lasttime;
	if (decode_ticks>500) decode_ticks=500;
	decode_lasttime=thistime;
	if (ov_openflags & 1) if (decode(0,&ov_song)) close_ovfile(1,&ov_song);
	if (ov_openflags & 2) if (decode(1,&ov_rhythm)) close_ovfile(2,&ov_rhythm);
	if (ov_openflags & 4) if (decode(2,&ov_guitar)) close_ovfile(4,&ov_guitar);
}

void audio_yield()
{
	if (playing.refreshsong)
	{
		playing.close_song();
		if (playing.songname[0]) playing.open_song();
		playing.refreshsong=0;
	}
	if (playing.ov_openflags) playing.some_predecode();
}

double song_time()
{
	return 0;
}
