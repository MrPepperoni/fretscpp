interface

uses audiofile;

int song_start(string path, int paused=0);
void song_stop();

struct tSongCtrl
{
	volatile int refreshsong;
	volatile int loopsong;    // TODO
	volatile int startpaused;
	
	/** last time when buffers were filled */
	int decode_lasttime;
	
	int decode_ticks;
	
	char songname[2048];
	/**
	 * Close song files and disable playback
	 */
	void close_song();
	/**
	 * open song with the given songname
	 * assumes the previous song has already been stopped
	 * 
	 */
	void open_song();
	/**
	 * estimate the amount of decoding necessary and ask songs
	 * to fill their buffers
	 */
	void some_predecode();
} songctrl;

tAudioFile songfiles[3];

void audio_yield();

implementation

uses audio;

int song_start(string path, int paused)
{
	int len=path.length();
	if (len>2047) len=2047;
	songctrl.refreshsong=0;
	songctrl.startpaused=paused;
	INFO(AUDIO,"Song start: >%s<\n", path);
	strncpy(songctrl.songname,path.c_str(),len);
	songctrl.songname[len]=0;
	songctrl.songname[2048]=0;
	songctrl.refreshsong=1;
	// TODO: need some thread protection here, in case we read this string at the same time
	// not a problem until we move audio decode to another thread
}

void song_stop()
{
	songctrl.songname[0]=0;
	songctrl.refreshsong=1;
}

void tSongCtrl::close_song()
{
	// critical section
	// this is needed because we are resetting the audiofile buffer pointers
	int i;
	for (i=0; i<3; i++) songfiles[i].close();
	SDL_LockAudio();
	for (i=0; i<3; i++) songfiles[i].reset();
	playing.songstarted=0;
	playing.songended=0;
	playing.stalled=1;
	SDL_UnlockAudio();
}

void tSongCtrl::open_song()
{
	// use char arrays here for thread safety reasons
	DBG(AUDIO,"opening song: >%s<\n", songname);
	char namelocal[2052];
	int i;
	strncpy(namelocal,songname,2048);
	namelocal[2048]=0;
	playing.pause=startpaused;
	int l=strlen(namelocal);
	if (!l) return;
	if (namelocal[l-1]=='/') strcat(namelocal,"song.ogg");
	songfiles[0].open(namelocal);
	if (namelocal[l-1]=='/')
	{
		namelocal[l]=0;
		strcat(namelocal,"rhythm.ogg");
		songfiles[1].open(namelocal);
		namelocal[l]=0;
		strcat(namelocal,"guitar.ogg");
		songfiles[2].open(namelocal);
	}
	playing.songstarted=1;	
}

void tSongCtrl::some_predecode()
{
	int thistime=SDL_GetTicks();
	decode_ticks=thistime-decode_lasttime;
	if (decode_ticks>500) decode_ticks=500;
	decode_lasttime=thistime;

	int target=4096;
	int target2=decode_ticks*obtained.freq/250;
	if (target2>target) target=target2; 
	// decode at least 4 times as much as it took to render one frame
	DBG(AUDIO,"Filling buffer, targets are: %d %d\n", target, target2);

	songfiles[0].decode(target);
	songfiles[1].decode(target);
	songfiles[2].decode(target);
}

void audio_yield()
{
	if (songctrl.refreshsong)
	{
		songctrl.close_song();
		if (songctrl.songname[0]) songctrl.open_song();
		songctrl.refreshsong=0;
	}
	songctrl.some_predecode();
}
