interface

struct tSettingsItem
{
public:
	enum {TYP_NULL=0,TYP_CHECKBOX,TYP_LISTBOX,TYP_RANGE,TYP_EDITBOX};
	string title;
	int typ;
	tSettingsItem(string tv="", int ty=0):title(tv),typ(ty) {;}
	virtual int handleevent(SDL_Event &event) { return 0; }
	virtual string toString() { return ""; }
};

struct tSIcheckbox:public tSettingsItem
{
	int *val;
	int locval;
	string toString();
	int handleevent(SDL_Event &event);
	tSIcheckbox(string t, int *v):tSettingsItem(t,TYP_CHECKBOX),val(v) { if (!v) val=&locval; }
};

struct tSIrange:public tSettingsItem
{
	tSIrange(string v, GLfloat miv, GLfloat mav, GLfloat *vv, GLfloat stv):
		tSettingsItem(v,TYP_RANGE),min(miv),max(mav),val(vv),step(stv) { if (!vv) val=&locval; capval(); }
	GLfloat *val;
	GLfloat min,max,step,locval;
	void capval() { if (*val<min) *val=min; if (*val>max) *val=max; }
	int handleevent(SDL_Event &event);
	string toString();
};

struct tSIintrange:public tSettingsItem
{
	tSIintrange(string v, int miv, int mav, int *vv, int stv=1):
		tSettingsItem(v,TYP_RANGE),min(miv),max(mav),val(vv),step(stv) { if (!vv) val=&locval; capval(); }
	int *val;
	int min,max,step,locval;
	void capval() { if (*val<min) *val=min; if (*val>max) *val=max; }
	int handleevent(SDL_Event &event);
	string toString();
};

struct tSIlist:public tSettingsItem
{
	tSIlist(string v, vector<string> cv,int *vv):
		tSettingsItem(v,TYP_RANGE),choices(cv),val(vv) { if (!vv) val=&locval; capval(); }
	vector<string> choices;
	int *val;
	int min,max,step,locval;
	void capval();
	int handleevent(SDL_Event &event);
	string toString();
};


class tScnSetBase: public sceneBase
{
public:
	vector<tSettingsItem*> item;
	int selected;
	int viewOffset;
	int viewSize;
	GLfloat scale,posx,posy,faderot;
	void init();
	virtual void itemAdjusted(int i) {;}
	GLfloat fadespeed() { return 100; }
	void additem(tSettingsItem *i);
	void render();
	void rendertext();
	void handleevent(SDL_Event &event);
};

implementation

uses configuration,scene;

void tSIlist::capval()
{
	MESSAGE("cap %d %d\n" &*val &(int)choices.size());
	if (*val<0) 
	{
		MESSAGE("capdn\n");
		*val=0; 
	}
	if (*val>=choices.size())
	{
		MESSAGE("capup\n");
		*val=choices.size()-1; 
	}
}

string tSIcheckbox::toString()
{
	string result;
	result="[";
	if (*val) result+="v";
	else result+=" ";
	result+="] ";
	result+=title;
	return result;
}

string tSIrange::toString()
{
	char a[32];
	string result="<-- ";
	result+=title;
	sprintf(a,": %0.2f",*val);
	result+=a;
	result+=" -->";
	return result;
}

string tSIlist::toString()
{
	char a[32];
	string result;
	if (*val>0) result+="< ";
	else result+="  ";
	result+=title+": ";
	result+=choices[*val];
	if (*val<choices.size()-1) result+=" >";
	return result;
}

string tSIintrange::toString()
{
	char a[32];
	string result="<-- ";
	result+=title;
	sprintf(a,": %d",*val);
	result+=a;
	result+=" -->";
	return result;
}


int tSIcheckbox::handleevent(SDL_Event &event)
{
	if (event.type!=SDL_KEYDOWN) return 0;
	if (event.key.keysym.sym!=SDLK_RETURN) return 0;
	*val=!*val;
	return 1;
}


int tSIintrange::handleevent(SDL_Event &event)
{
	if (event.type!=SDL_KEYDOWN) return 0;
	switch(event.key.keysym.sym)
	{
	case SDLK_LEFT:
		if (*val<=min) return 0;
		*val-=step;
		if (*val<min) *val=min;
		return 1;
	case SDLK_RIGHT:
		if (*val>=max) return 0;
		*val+=step;
		if (*val>max) *val=max;
		return 1;
	}
	return 0;
}

int tSIlist::handleevent(SDL_Event &event)
{
	if (event.type!=SDL_KEYDOWN) return 0;
	//MESSAGE("choices: %d %d\n" &*val &choices.size());
	
	switch(event.key.keysym.sym)
	{
	case SDLK_LEFT:
		if (*val<=0) return 0;
		*val-=1;
		capval();
		return 1;
	case SDLK_RIGHT:
		if (*val>=choices.size()-1) return 0;
		*val+=1;
		capval();
		return 1;
	}
	return 0;
}

int tSIrange::handleevent(SDL_Event &event)
{
	if (event.type!=SDL_KEYDOWN) return 0;
	switch(event.key.keysym.sym)
	{
	case SDLK_LEFT:
		if (*val<=min) return 0;
		*val-=step;
		if (*val<min) *val=min;
		return 1;
	case SDLK_RIGHT:
		if (*val>=max) return 0;
		*val+=step;
		if (*val>max) *val=max;
		return 1;
	}
	return 0;
}

void tScnSetBase::init()
{
	// TOFIX: this will create trouble during song play
	SDL_EnableKeyRepeat(133,33);
	selected=0;
	viewOffset=0;
	viewSize=12;
	posx=-38;
	posy=-6;
	scale=3;
	sceneBase::init();
}

void tScnSetBase::additem(tSettingsItem *a)
{
	item.push_back(a);
}

void tScnSetBase::handleevent(SDL_Event &event)
{
	switch (event.type)
	{
	case SDL_KEYDOWN:
		switch (event.key.keysym.sym) 
		{
			case SDLK_ESCAPE:
			case SDLK_q:
				itemAdjusted(-1);
				popscene();
				break;
			case SDLK_UP:
				if (selected>0) selected--;
				break;
			case SDLK_DOWN:
				if (selected<item.size()-1) selected++;
				break;
			case SDLK_HOME:
				selected=0;
				break;
			case SDLK_END:
				selected=item.size()-1;
				break;
			case SDLK_PAGEUP:
				selected-=viewSize;
				if (selected<0) selected=0;
				break;
			case SDLK_PAGEDOWN:
				selected+=viewSize;
				if (selected>=item.size()) selected=item.size()-1;
				break;
			//case SDLK_RETURN:	
			default:
				if (item[selected]->handleevent(event))
					itemAdjusted(selected);
				break;
		}
		break;
	}
	// fix view offset
	if (selected<viewOffset) viewOffset=selected;
	if (viewOffset+viewSize-1<selected) viewOffset=selected+1-viewSize;
}

void tScnSetBase::render()
{
	paintrotback();
	rendertext();
}

void tScnSetBase::rendertext()
{
	faderot=scn.fade*2-1;
	if (faderot<0) faderot=0;
	
	if (scn.menufade==1) return;
	GLfloat v,x,y,h,w;
	h=scr_height;
	w=scr_width;
	x=posx; y=posy;
	v=faderot*faderot;
	int i;
	for (i=viewOffset; (i<viewOffset+viewSize) && i<item.size(); i++)
	{
		glLoadIdentity();
		glRotatef(v*45,0.0,0.0,1.0);
		glColor3f(0.0f,0.0f,0.0f);
		GLfloat dy=0;
		if (selected==i && scn.menufade==0)
			dy=sin(scn.time*8)*scale*0.1;
		string itemstring=item[i]->toString();
		//MESSAGE("item:%s %f %f %f\n" &itemstring &x &(y+dy) &scale);
		deffont.displayString(itemstring.c_str(),x-(v/4)*scale+scale*0.05,y+scale*0.05+dy,scale);
		
		if (selected==i && scn.menufade==0)
			glColor3f(1.0f,0.7f,0.0f);
		else {
			glColor3f(0.8f,0.3f,0.0f);	
		}
		
		deffont.displayString(itemstring.c_str(),x-(v/4)*scale           ,y+dy           ,scale);
		v=v*2;
		y=y+scale;
		if (v>4) break;
	}
}

